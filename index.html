<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agar.io Clone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            font-family: 'Arial', sans-serif;
        }

        canvas {
            display: block;
            background-color: #e0f7fa;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 200px;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 10px;
            display: flex;
            gap: 10px;
        }

        .btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .btn:hover {
            background-color: #388E3C;
            transform: scale(1.05);
        }

        .btn-split {
            background-color: #2196F3;
        }

        .btn-split:hover {
            background-color: #1976D2;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
        }

        .player-name {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            padding: 5px 10px;
        }
    </style>
</head>

<body class="bg-gray-100">
    <div class="game-container">
        <div class="player-name">
            <input type="text" id="playerName" placeholder="Your Name" class="border rounded px-2 py-1" value="Player">
        </div>
        <canvas id="gameCanvas"></canvas>

        <div class="leaderboard">
            <h2 class="text-lg font-bold mb-2 border-b pb-1">Leaderboard</h2>
            <ul id="leaderboardList" class="space-y-1"></ul>
        </div>

        <div class="controls">
            <button id="splitBtn" class="btn btn-split">SPLIT (SPACE)</button>
        </div>

        <div class="game-over" id="gameOver">
            <h2 class="text-2xl font-bold mb-4">Game Over</h2>
            <p id="finalScore" class="mb-4">You reached size: 0</p>
            <button id="restartBtn" class="btn">Play Again</button>
        </div>
    </div>

    <script>
        // Game constants
        const CANVAS_WIDTH = window.innerWidth;
        const CANVAS_HEIGHT = window.innerHeight;
        const WORLD_WIDTH = 5000;
        const WORLD_HEIGHT = 5000;
        const PELLET_COUNT = 500;
        const BOT_COUNT = 20;
        const COLORS = [
            '#FF5252', '#FF4081', '#E040FB', '#7C4DFF', '#536DFE',
            '#448AFF', '#40C4FF', '#18FFFF', '#64FFDA', '#69F0AE',
            '#B2FF59', '#EEFF41', '#FFFF00', '#FFD740', '#FFAB40',
            '#FF6E40', '#FF5722', '#795548', '#9E9E9E', '#607D8B'
        ];

        // Game variables
        let canvas, ctx;
        let player;
        let pellets = [];
        let bots = [];
        let gameRunning = true;
        let mouseX = 0, mouseY = 0;
        let keys = {};
        let camera = { x: 0, y: 0, scale: 1 };
        let leaderboard = [];

        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Create player
            player = {
                x: WORLD_WIDTH / 2,
                y: WORLD_HEIGHT / 2,
                radius: 20,
                color: '#2196F3',
                speed: 5,
                mass: 20 * 20, // mass = radius^2
                cells: [],
                name: document.getElementById('playerName').value || 'Player',
                isPlayer: true
            };

            // Create pellets
            for (let i = 0; i < PELLET_COUNT; i++) {
                pellets.push(createPellet());
            }

            // Create bots
            for (let i = 0; i < BOT_COUNT; i++) {
                bots.push(createBot());
            }

            // Initialize leaderboard
            updateLeaderboard();

            // Event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            canvas.addEventListener('mousemove', handleMouseMove);
            document.getElementById('splitBtn').addEventListener('click', splitPlayer);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            document.getElementById('playerName').addEventListener('change', updatePlayerName);

            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        // Resize canvas to window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Create a pellet
        function createPellet() {
            return {
                x: Math.random() * WORLD_WIDTH,
                y: Math.random() * WORLD_HEIGHT,
                radius: 5 + Math.random() * 3,
                color: getRandomColor()
            };
        }

        // Create a bot
        function createBot() {
            const radius = 15 + Math.random() * 20;
            return {
                x: Math.random() * WORLD_WIDTH,
                y: Math.random() * WORLD_HEIGHT,
                radius: radius,
                color: getRandomColor(),
                speed: 3 + Math.random() * 2,
                mass: radius * radius,
                target: null,
                direction: { x: 0, y: 0 },
                name: `Bot ${Math.floor(Math.random() * 1000)}`,
                isPlayer: false,
                cells: []
            };
        }

        // Get random color
        function getRandomColor() {
            return COLORS[Math.floor(Math.random() * COLORS.length)];
        }

        // Handle keyboard input
        function handleKeyDown(e) {
            keys[e.key] = true;

            if (e.key === ' ' && gameRunning) {
                splitPlayer();
            }
        }

        function handleKeyUp(e) {
            keys[e.key] = false;
        }

        // Handle mouse movement
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        }

        // Update player name
        function updatePlayerName() {
            player.name = document.getElementById('playerName').value || 'Player';
        }

        // Split player cell
        function splitPlayer() {
            if (player.cells.length > 3) return; // Limit splits

            const newRadius = player.radius * 0.7;
            const angle = Math.atan2(mouseY - CANVAS_HEIGHT / 2, mouseX - CANVAS_WIDTH / 2);

            const newCell = {
                x: player.x,
                y: player.y,
                radius: newRadius,
                color: player.color,
                speed: player.speed * 1.5,
                mass: newRadius * newRadius,
                direction: {
                    x: Math.cos(angle) * 10,
                    y: Math.sin(angle) * 10
                },
                name: player.name,
                isPlayer: true
            };

            player.radius = newRadius;
            player.mass = newRadius * newRadius;
            player.cells.push(newCell);
        }

        // Main game loop
        function gameLoop() {
            if (!gameRunning) return;

            // Clear canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Update game state
            updatePlayer();
            updateBots();
            updateCamera();
            checkCollisions();
            updateLeaderboard();

            // Draw game
            drawWorld();
            drawPellets();
            drawBots();
            drawPlayer();

            // Continue game loop
            requestAnimationFrame(gameLoop);
        }

        // Update player position
        function updatePlayer() {
            // Handle movement
            let moveX = 0, moveY = 0;

            // Mouse movement (relative to center)
            if (mouseX !== 0 || mouseY !== 0) {
                const centerX = CANVAS_WIDTH / 2;
                const centerY = CANVAS_HEIGHT / 2;
                const angle = Math.atan2(mouseY - centerY, mouseX - centerX);
                moveX = Math.cos(angle) * player.speed;
                moveY = Math.sin(angle) * player.speed;
            }

            // Keyboard movement
            if (keys['ArrowUp'] || keys['w']) moveY -= player.speed;
            if (keys['ArrowDown'] || keys['s']) moveY += player.speed;
            if (keys['ArrowLeft'] || keys['a']) moveX -= player.speed;
            if (keys['ArrowRight'] || keys['d']) moveX += player.speed;

            // Normalize diagonal movement
            if (moveX !== 0 && moveY !== 0) {
                const len = Math.sqrt(moveX * moveX + moveY * moveY);
                moveX = (moveX / len) * player.speed;
                moveY = (moveY / len) * player.speed;
            }

            // Update position
            player.x += moveX;
            player.y += moveY;

            // Keep player within world bounds
            player.x = Math.max(player.radius, Math.min(WORLD_WIDTH - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(WORLD_HEIGHT - player.radius, player.y));

            // Update player cells (from splits)
            for (let i = player.cells.length - 1; i >= 0; i--) {
                const cell = player.cells[i];

                // Apply movement
                cell.x += cell.direction.x;
                cell.y += cell.direction.y;

                // Slow down over time
                cell.direction.x *= 0.95;
                cell.direction.y *= 0.95;

                // Check if cell should recombine with player
                const dx = player.x - cell.x;
                const dy = player.y - cell.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < player.radius + cell.radius - 10) {
                    // Recombine
                    player.radius = Math.sqrt(player.mass + cell.mass);
                    player.mass = player.radius * player.radius;
                    player.cells.splice(i, 1);
                }

                // Keep cell within world bounds
                cell.x = Math.max(cell.radius, Math.min(WORLD_WIDTH - cell.radius, cell.x));
                cell.y = Math.max(cell.radius, Math.min(WORLD_HEIGHT - cell.radius, cell.y));
            }

            // Update player speed based on size (bigger = slower)
            player.speed = 5 + (100 / player.radius);
        }

        // Update bots AI
        function updateBots() {
            bots.forEach(bot => {
                // Update bot cells (from splits)
                for (let i = bot.cells.length - 1; i >= 0; i--) {
                    const cell = bot.cells[i];

                    // Apply movement
                    cell.x += cell.direction.x;
                    cell.y += cell.direction.y;

                    // Slow down over time
                    cell.direction.x *= 0.95;
                    cell.direction.y *= 0.95;

                    // Check if cell should recombine with bot
                    const dx = bot.x - cell.x;
                    const dy = bot.y - cell.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < bot.radius + cell.radius - 10) {
                        // Recombine
                        bot.radius = Math.sqrt(bot.mass + cell.mass);
                        bot.mass = bot.radius * bot.radius;
                        bot.cells.splice(i, 1);
                    }

                    // Keep cell within world bounds
                    cell.x = Math.max(cell.radius, Math.min(WORLD_WIDTH - cell.radius, cell.x));
                    cell.y = Math.max(cell.radius, Math.min(WORLD_HEIGHT - cell.radius, cell.y));
                }

                // Update bot speed based on size
                bot.speed = 3 + (100 / bot.radius);

                // AI behavior
                if (!bot.target || Math.random() < 0.01) {
                    // Find new target
                    let closestPellet = null;
                    let closestDistance = Infinity;

                    // Find closest pellet
                    pellets.forEach(pellet => {
                        const dx = pellet.x - bot.x;
                        const dy = pellet.y - bot.y;
                        const distance = dx * dx + dy * dy;

                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestPellet = pellet;
                        }
                    });

                    // Find potential prey (smaller cells)
                    let prey = null;
                    let preyDistance = Infinity;

                    // Check player
                    if (player.mass < bot.mass * 0.8) {
                        const dx = player.x - bot.x;
                        const dy = player.y - bot.y;
                        const distance = dx * dx + dy * dy;

                        if (distance < preyDistance) {
                            preyDistance = distance;
                            prey = player;
                        }
                    }

                    // Check player cells
                    player.cells.forEach(cell => {
                        if (cell.mass < bot.mass * 0.8) {
                            const dx = cell.x - bot.x;
                            const dy = cell.y - bot.y;
                            const distance = dx * dx + dy * dy;

                            if (distance < preyDistance) {
                                preyDistance = distance;
                                prey = cell;
                            }
                        }
                    });

                    // Check other bots
                    bots.forEach(otherBot => {
                        if (otherBot !== bot && otherBot.mass < bot.mass * 0.8) {
                            const dx = otherBot.x - bot.x;
                            const dy = otherBot.y - bot.y;
                            const distance = dx * dx + dy * dy;

                            if (distance < preyDistance) {
                                preyDistance = distance;
                                prey = otherBot;
                            }
                        }
                    });

                    // Check other bot cells
                    bots.forEach(otherBot => {
                        if (otherBot !== bot) {
                            otherBot.cells.forEach(cell => {
                                if (cell.mass < bot.mass * 0.8) {
                                    const dx = cell.x - bot.x;
                                    const dy = cell.y - bot.y;
                                    const distance = dx * dx + dy * dy;

                                    if (distance < preyDistance) {
                                        preyDistance = distance;
                                        prey = cell;
                                    }
                                }
                            });
                        }
                    });

                    // Find threats (bigger cells to avoid)
                    let threat = null;
                    let threatDistance = Infinity;

                    // Check player
                    if (player.mass > bot.mass * 1.2) {
                        const dx = player.x - bot.x;
                        const dy = player.y - bot.y;
                        const distance = dx * dx + dy * dy;

                        if (distance < threatDistance) {
                            threatDistance = distance;
                            threat = player;
                        }
                    }

                    // Check player cells
                    player.cells.forEach(cell => {
                        if (cell.mass > bot.mass * 1.2) {
                            const dx = cell.x - bot.x;
                            const dy = cell.y - bot.y;
                            const distance = dx * dx + dy * dy;

                            if (distance < threatDistance) {
                                threatDistance = distance;
                                threat = cell;
                            }
                        }
                    });

                    // Check other bots
                    bots.forEach(otherBot => {
                        if (otherBot !== bot && otherBot.mass > bot.mass * 1.2) {
                            const dx = otherBot.x - bot.x;
                            const dy = otherBot.y - bot.y;
                            const distance = dx * dx + dy * dy;

                            if (distance < threatDistance) {
                                threatDistance = distance;
                                threat = otherBot;
                            }
                        }
                    });

                    // Check other bot cells
                    bots.forEach(otherBot => {
                        if (otherBot !== bot) {
                            otherBot.cells.forEach(cell => {
                                if (cell.mass > bot.mass * 1.2) {
                                    const dx = cell.x - bot.x;
                                    const dy = cell.y - bot.y;
                                    const distance = dx * dx + dy * dy;

                                    if (distance < threatDistance) {
                                        threatDistance = distance;
                                        threat = cell;
                                    }
                                }
                            });
                        }
                    });

                    // Decide behavior based on what's nearby
                    if (threat && threatDistance < 100000) {
                        // Flee from threat
                        const angle = Math.atan2(bot.y - threat.y, bot.x - threat.x);
                        bot.target = {
                            x: bot.x + Math.cos(angle) * 500,
                            y: bot.y + Math.sin(angle) * 500
                        };
                    } else if (prey && preyDistance < 100000) {
                        // Chase prey
                        bot.target = prey;
                    } else if (closestPellet && closestDistance < 200000) {
                        // Go for pellet
                        bot.target = closestPellet;
                    } else {
                        // Wander randomly
                        const angle = Math.random() * Math.PI * 2;
                        bot.target = {
                            x: bot.x + Math.cos(angle) * 200,
                            y: bot.y + Math.sin(angle) * 200
                        };
                    }
                }

                // Move toward target
                if (bot.target) {
                    const dx = bot.target.x - bot.x;
                    const dy = bot.target.y - bot.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 10) {
                        const angle = Math.atan2(dy, dx);
                        bot.x += Math.cos(angle) * bot.speed;
                        bot.y += Math.sin(angle) * bot.speed;
                    }
                }

                // Randomly split (10% chance when big enough)
                if (bot.radius > 40 && Math.random() < 0.001 && bot.cells.length < 2) {
                    const angle = Math.random() * Math.PI * 2;
                    const newRadius = bot.radius * 0.7;

                    const newCell = {
                        x: bot.x,
                        y: bot.y,
                        radius: newRadius,
                        color: bot.color,
                        speed: bot.speed * 1.5,
                        mass: newRadius * newRadius,
                        direction: {
                            x: Math.cos(angle) * 10,
                            y: Math.sin(angle) * 10
                        },
                        name: bot.name,
                        isPlayer: false
                    };

                    bot.radius = newRadius;
                    bot.mass = newRadius * newRadius;
                    bot.cells.push(newCell);
                }

                // Keep bot within world bounds
                bot.x = Math.max(bot.radius, Math.min(WORLD_WIDTH - bot.radius, bot.x));
                bot.y = Math.max(bot.radius, Math.min(WORLD_HEIGHT - bot.radius, bot.y));
            });
        }

        // Update camera position
        function updateCamera() {
            // Calculate total player mass (including split cells)
            let totalMass = player.mass;
            player.cells.forEach(cell => {
                totalMass += cell.mass;
            });

            // Calculate average position of all player cells
            let totalX = player.x * player.mass;
            let totalY = player.y * player.mass;

            player.cells.forEach(cell => {
                totalX += cell.x * cell.mass;
                totalY += cell.y * cell.mass;
            });

            const avgX = totalX / totalMass;
            const avgY = totalY / totalMass;

            // Smooth camera movement
            camera.x += (avgX - camera.x) * 0.1;
            camera.y += (avgY - camera.y) * 0.1;

            // Dynamic zoom based on player size
            const targetScale = Math.min(1, 100 / Math.sqrt(totalMass));
            camera.scale += (targetScale - camera.scale) * 0.1;
        }

        // Check collisions
        function checkCollisions() {
            // Player collisions with pellets
            for (let i = pellets.length - 1; i >= 0; i--) {
                const pellet = pellets[i];
                const dx = player.x - pellet.x;
                const dy = player.y - pellet.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < player.radius + pellet.radius) {
                    // Player eats pellet
                    player.mass += pellet.radius * pellet.radius;
                    player.radius = Math.sqrt(player.mass);

                    // Replace pellet
                    pellets.splice(i, 1);
                    pellets.push(createPellet());
                }
            }

            // Player cell collisions with pellets
            player.cells.forEach(cell => {
                for (let i = pellets.length - 1; i >= 0; i--) {
                    const pellet = pellets[i];
                    const dx = cell.x - pellet.x;
                    const dy = cell.y - pellet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < cell.radius + pellet.radius) {
                        // Cell eats pellet
                        cell.mass += pellet.radius * pellet.radius;
                        cell.radius = Math.sqrt(cell.mass);

                        // Replace pellet
                        pellets.splice(i, 1);
                        pellets.push(createPellet());
                    }
                }
            });

            // Bot collisions with pellets
            bots.forEach(bot => {
                for (let i = pellets.length - 1; i >= 0; i--) {
                    const pellet = pellets[i];
                    const dx = bot.x - pellet.x;
                    const dy = bot.y - pellet.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < bot.radius + pellet.radius) {
                        // Bot eats pellet
                        bot.mass += pellet.radius * pellet.radius;
                        bot.radius = Math.sqrt(bot.mass);

                        // Replace pellet
                        pellets.splice(i, 1);
                        pellets.push(createPellet());
                    }
                }

                // Bot cell collisions with pellets
                bot.cells.forEach(cell => {
                    for (let i = pellets.length - 1; i >= 0; i--) {
                        const pellet = pellets[i];
                        const dx = cell.x - pellet.x;
                        const dy = cell.y - pellet.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < cell.radius + pellet.radius) {
                            // Cell eats pellet
                            cell.mass += pellet.radius * pellet.radius;
                            cell.radius = Math.sqrt(cell.mass);

                            // Replace pellet
                            pellets.splice(i, 1);
                            pellets.push(createPellet());
                        }
                    }
                });
            });

            // Player collisions with bots
            for (let i = bots.length - 1; i >= 0; i--) {
                const bot = bots[i];
                const dx = player.x - bot.x;
                const dy = player.y - bot.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < player.radius + bot.radius) {
                    if (player.mass > bot.mass * 1.1) {
                        // Player eats bot
                        player.mass += bot.mass;
                        player.radius = Math.sqrt(player.mass);

                        // Replace bot
                        bots.splice(i, 1);
                        bots.push(createBot());
                    } else if (bot.mass > player.mass * 1.1) {
                        // Bot eats player - game over
                        gameOver();
                        return;
                    }
                }
            }

            // Player cell collisions with bots
            for (let i = 0; i < player.cells.length; i++) {
                const cell = player.cells[i];

                for (let j = bots.length - 1; j >= 0; j--) {
                    const bot = bots[j];
                    const dx = cell.x - bot.x;
                    const dy = cell.y - bot.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < cell.radius + bot.radius) {
                        if (cell.mass > bot.mass * 1.1) {
                            // Player cell eats bot
                            cell.mass += bot.mass;
                            cell.radius = Math.sqrt(cell.mass);

                            // Replace bot
                            bots.splice(j, 1);
                            bots.push(createBot());
                        } else if (bot.mass > cell.mass * 1.1) {
                            // Bot eats player cell
                            bot.mass += cell.mass;
                            bot.radius = Math.sqrt(bot.mass);

                            // Remove player cell
                            player.cells.splice(i, 1);
                            i--;
                            break;
                        }
                    }
                }
            }

            // Player collisions with bot cells
            for (let i = bots.length - 1; i >= 0; i--) {
                const bot = bots[i];

                for (let j = bot.cells.length - 1; j >= 0; j--) {
                    const botCell = bot.cells[j];
                    const dx = player.x - botCell.x;
                    const dy = player.y - botCell.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < player.radius + botCell.radius) {
                        if (player.mass > botCell.mass * 1.1) {
                            // Player eats bot cell
                            player.mass += botCell.mass;
                            player.radius = Math.sqrt(player.mass);

                            // Remove bot cell
                            bot.cells.splice(j, 1);
                        } else if (botCell.mass > player.mass * 1.1) {
                            // Bot cell eats player - game over
                            gameOver();
                            return;
                        }
                    }
                }
            }

            // Player cell collisions with bot cells
            for (let i = 0; i < player.cells.length; i++) {
                const playerCell = player.cells[i];

                for (let j = bots.length - 1; j >= 0; j--) {
                    const bot = bots[j];

                    for (let k = bot.cells.length - 1; k >= 0; k--) {
                        const botCell = bot.cells[k];
                        const dx = playerCell.x - botCell.x;
                        const dy = playerCell.y - botCell.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < playerCell.radius + botCell.radius) {
                            if (playerCell.mass > botCell.mass * 1.1) {
                                // Player cell eats bot cell
                                playerCell.mass += botCell.mass;
                                playerCell.radius = Math.sqrt(playerCell.mass);

                                // Remove bot cell
                                bot.cells.splice(k, 1);
                            } else if (botCell.mass > playerCell.mass * 1.1) {
                                // Bot cell eats player cell
                                botCell.mass += playerCell.mass;
                                botCell.radius = Math.sqrt(botCell.mass);

                                // Remove player cell
                                player.cells.splice(i, 1);
                                i--;
                                break;
                            }
                        }
                    }
                }
            }

            // Bot collisions with other bots
            for (let i = 0; i < bots.length; i++) {
                const bot1 = bots[i];

                for (let j = i + 1; j < bots.length; j++) {
                    const bot2 = bots[j];
                    const dx = bot1.x - bot2.x;
                    const dy = bot1.y - bot2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < bot1.radius + bot2.radius) {
                        if (bot1.mass > bot2.mass * 1.1) {
                            // Bot1 eats bot2
                            bot1.mass += bot2.mass;
                            bot1.radius = Math.sqrt(bot1.mass);

                            // Replace bot2
                            bots.splice(j, 1);
                            j--;
                        } else if (bot2.mass > bot1.mass * 1.1) {
                            // Bot2 eats bot1
                            bot2.mass += bot1.mass;
                            bot2.radius = Math.sqrt(bot2.mass);

                            // Replace bot1
                            bots.splice(i, 1);
                            i--;
                            break;
                        }
                    }
                }
            }
        }

        // Update leaderboard
        function updateLeaderboard() {
            // Create array of all entities (player, player cells, bots, bot cells)
            const allEntities = [];

            // Add player
            allEntities.push({
                name: player.name,
                mass: player.mass,
                isPlayer: true
            });

            // Add player cells
            player.cells.forEach(cell => {
                allEntities.push({
                    name: cell.name,
                    mass: cell.mass,
                    isPlayer: true
                });
            });

            // Add bots
            bots.forEach(bot => {
                allEntities.push({
                    name: bot.name,
                    mass: bot.mass,
                    isPlayer: false
                });

                // Add bot cells
                bot.cells.forEach(cell => {
                    allEntities.push({
                        name: cell.name,
                        mass: cell.mass,
                        isPlayer: false
                    });
                });
            });

            // Sort by mass (descending)
            allEntities.sort((a, b) => b.mass - a.mass);

            // Take top 10
            leaderboard = allEntities.slice(0, 10);

            // Update leaderboard UI
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = '';

            leaderboard.forEach((entity, index) => {
                const li = document.createElement('li');
                li.className = 'flex justify-between items-center';

                const nameSpan = document.createElement('span');
                nameSpan.className = entity.isPlayer ? 'font-bold text-blue-600' : 'text-gray-700';
                nameSpan.textContent = `${index + 1}. ${entity.name}`;

                const massSpan = document.createElement('span');
                massSpan.className = 'font-semibold';
                massSpan.textContent = Math.round(entity.mass);

                li.appendChild(nameSpan);
                li.appendChild(massSpan);
                leaderboardList.appendChild(li);
            });
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = `You reached size: ${Math.round(player.mass)}`;
            document.getElementById('gameOver').style.display = 'block';
        }

        // Restart game
        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';

            // Reset game state
            pellets = [];
            bots = [];
            gameRunning = true;

            // Create new player
            player = {
                x: WORLD_WIDTH / 2,
                y: WORLD_HEIGHT / 2,
                radius: 20,
                color: '#2196F3',
                speed: 5,
                mass: 20 * 20,
                cells: [],
                name: document.getElementById('playerName').value || 'Player',
                isPlayer: true
            };

            // Create new pellets
            for (let i = 0; i < PELLET_COUNT; i++) {
                pellets.push(createPellet());
            }

            // Create new bots
            for (let i = 0; i < BOT_COUNT; i++) {
                bots.push(createBot());
            }

            // Reset camera
            camera = { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2, scale: 1 };

            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        // Draw world background
        function drawWorld() {
            // Draw grid (scaled with camera)
            ctx.save();
            ctx.translate(CANVAS_WIDTH / 2 - camera.x * camera.scale, CANVAS_HEIGHT / 2 - camera.y * camera.scale);
            ctx.scale(camera.scale, camera.scale);

            ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.lineWidth = 1;

            const gridSize = 100;
            const startX = Math.floor((camera.x - CANVAS_WIDTH / 2 / camera.scale) / gridSize) * gridSize;
            const startY = Math.floor((camera.y - CANVAS_HEIGHT / 2 / camera.scale) / gridSize) * gridSize;
            const endX = startX + CANVAS_WIDTH / camera.scale + gridSize * 2;
            const endY = startY + CANVAS_HEIGHT / camera.scale + gridSize * 2;

            for (let x = startX; x < endX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }

            for (let y = startY; y < endY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Draw pellets
        function drawPellets() {
            ctx.save();
            ctx.translate(CANVAS_WIDTH / 2 - camera.x * camera.scale, CANVAS_HEIGHT / 2 - camera.y * camera.scale);
            ctx.scale(camera.scale, camera.scale);

            pellets.forEach(pellet => {
                ctx.beginPath();
                ctx.arc(pellet.x, pellet.y, pellet.radius, 0, Math.PI * 2);
                ctx.fillStyle = pellet.color;
                ctx.fill();
            });

            ctx.restore();
        }

        // Draw player
        function drawPlayer() {
            ctx.save();
            ctx.translate(CANVAS_WIDTH / 2 - camera.x * camera.scale, CANVAS_HEIGHT / 2 - camera.y * camera.scale);
            ctx.scale(camera.scale, camera.scale);

            // Draw player
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = player.color;
            ctx.fill();

            // Draw player outline
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw player name
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `${Math.max(12, player.radius / 3)}px Arial`;
            ctx.fillText(player.name, player.x, player.y);

            // Draw player cells
            player.cells.forEach(cell => {
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, cell.radius, 0, Math.PI * 2);
                ctx.fillStyle = cell.color;
                ctx.fill();

                // Draw cell outline
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw cell name
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `${Math.max(12, cell.radius / 3)}px Arial`;
                ctx.fillText(cell.name, cell.x, cell.y);
            });

            ctx.restore();
        }

        // Draw bots
        function drawBots() {
            ctx.save();
            ctx.translate(CANVAS_WIDTH / 2 - camera.x * camera.scale, CANVAS_HEIGHT / 2 - camera.y * camera.scale);
            ctx.scale(camera.scale, camera.scale);

            bots.forEach(bot => {
                // Draw bot
                ctx.beginPath();
                ctx.arc(bot.x, bot.y, bot.radius, 0, Math.PI * 2);
                ctx.fillStyle = bot.color;
                ctx.fill();

                // Draw bot outline
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw bot name
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `${Math.max(12, bot.radius / 3)}px Arial`;
                ctx.fillText(bot.name, bot.x, bot.y);

                // Draw bot cells
                bot.cells.forEach(cell => {
                    ctx.beginPath();
                    ctx.arc(cell.x, cell.y, cell.radius, 0, Math.PI * 2);
                    ctx.fillStyle = cell.color;
                    ctx.fill();

                    // Draw cell outline
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Draw cell name
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = `${Math.max(12, cell.radius / 3)}px Arial`;
                    ctx.fillText(cell.name, cell.x, cell.y);
                });
            });

            ctx.restore();
        }

        // Start game
        window.onload = init;
    </script>
</body>

</html>